---
# try also 'default' to start simple
theme: seriph
# random image from a curated Unsplash collection by Anthony
# like them? see https://unsplash.com/collections/94734566/slidev
background: https://source.unsplash.com/collection/94734566/1920x1080
# apply any windi css classes to the current slide
class: 'text-center'
# https://sli.dev/custom/highlighters.html
highlighter: shiki
# show line numbers in code blocks
lineNumbers: true
# persist drawings in exports and build
drawings:
  persist: false
# デフォルトだとdevとexportで適用されるフォントが異なるため明示的に指定する
fonts:
  # basically the text
  sans: 'Noto Sans JP'
  # use with `font-serif` css class from windicss
  serif: 'Robot Slab'
  # for code blocks, inline code, etc.
  mono: 'Fira Code'
---

# 社内読書会
## ソフトウェアアーキテクチャの基礎
### 3章 モジュール性

<Profile />

<div class="abs-br m-6 flex gap-2">
  <GitHubIcon id="krabben16" />
</div>

---

# はじめに
- モジュールの概念はソフトウェアアーキテクチャの世界で一般的、ただし定義は曖昧
- アーキテクチャを分析するツールの多くはモジュール性の概念に依存している
    - メトリクス、適応度関数、可視化
- モジュール性とはアーキテクチャの要素同士の繋がりの原理を表すもの
- 優れたモジュール性を維持することは**暗黙的なアーキテクチャ特性**となっている

---

# 3.1 定義
- 関連するコードを論理的にグループ化すること = モジュール化
  - オブジェクト指向言語のクラス
  - 構造化言語/関数型言語の関数
  - Javaの例 `com.mycompany.customer` 顧客関連のモジュール
- 現代のプログラミング言語はさまざまなパッケージ化の仕組みを備える
  - 関数、クラス、名前空間など
- アーキテクトは開発者がコードをどのようにパッケージ化しているか注意しなくてはならない
  - 複数のパッケージが密結合だと別の作業に再利用することが難しくなるため

---

# 3.2 モジュール性の計測
- アーキテクトがモジュール性を把握することに役立つメトリクスが研究されてきた
- 凝集度、結合度、コナーセンスという考え方に焦点を当てる

---

# 3.2.1 凝集度 (Cohesion, コヒージョン)
- モジュールの要素がどの程度そのモジュールに収まっているかを示す度合い
- 関連する要素が全て1箇所にまとまっている状態が凝集したモジュールの理想
- 凝集度の高いモジュールを分割すると、複数のモジュールを結合しなければならなくなるため可読性が下がる

> 凝集度の高いモジュールは、堅牢性、信頼性、再利用性、読みやすさなどの点で好ましく、凝集度の低いモジュールは保守/評価/再利用/読解が難しいため好ましくないとされる。

https://ja.wikipedia.org/wiki/%E5%87%9D%E9%9B%86%E5%BA%A6

---

# 凝集度の尺度 1
- 機能的凝集
    - 関連する要素だけでモジュールが構成されている
- 逐次的凝集
    - 一方のモジュールが出力したデータをもう一方のモジュールが入力データとして扱う
- 通信的凝集
    - 2つのモジュールが通信の連鎖を形成
        - DBにレコードを追加し、その情報に基づいてメールを送信する
- 手続き的凝集
    - 2つのモジュールは特定の順序でコードを実行する必要がある

---

# 凝集度の尺度 2
- 時間的凝集
    -  モジュール間で時間的な依存関係がある
        - システム起動時に初期化しなければならない処理群など
- 論理的凝集
    - モジュール内の要素は論理的に関連しているが機能的に関連していない
    - JavaのStringUtilsクラス
        - 互いに関連してない静的メソッドの集まり
- 偶発的凝集
    - モジュール内の要素は同じファイルに存在する以外に関連性がない
    - 最悪な形での凝集

---

# 次のモジュールを分割するべきか
<div grid="~ cols-2 gap-4">
<div>

```
- 顧客管理
    - 顧客の追加
    - 顧客の更新
    - 顧客の取得
    - 顧客への通知
    - 顧客の注文の取得
    - 顧客の注文のキャンセル
```

</div>
<div>

```
- 顧客管理
    - 顧客の追加
    - 顧客の更新
    - 顧客の取得
    - 顧客への通知
- 注文管理
    - 顧客の注文の取得
    - 顧客の注文のキャンセル
```

</div>
</div>

--- 

# 次のモジュールを分割するべきか
- 答えは場合による
    - 注文管理の操作が2つだけの場合
        - これらの操作を顧客管理に入れておくのは理にかなっている
        - モジュールを分けると、モジュール間に結合が生じて可読性が下がる
    - 顧客管理の規模がさらに大きくなる場合
        - 開発者が振る舞いを抽出したくなるかもしれない

---

# 凝集度を判断するためのメトリクス
- CKメトリクス
    - オブジェクト指向ソフトウェアの特手の側面を計測するために考案された一連のメトリクス
    - 結合度メトリクス、循環的複雑度などを含む
    - LCOM（メソッドの凝集度の欠如）
-  ソフトウェアメトリクスは欠陥を持つ
    - メトリクスが見つけられるのは構造的な凝集度の欠如
    - 要素が適切に組み合わされているかを論理的に判断できない
    - 「どうやって」よりも「なぜ」の方がずっと重要
        - ソフトウェアアーキテクチャ第二法則

---

# 3.2.2 結合度 (Coupling, カップリング)[^1]

<div grid="~ cols-2 gap-4">
<div>

- メソッドの呼び出しと戻りはコールグラフの形を取るため、グラフ理論に基づいた数学的な分析ができる
    - コールグラフ = コンピュータプログラムの関数の呼び出し関係を表現した有向グラフで、ソースコードの構造を可視化したもの。

</div>
<div>

<img src="https://gyazo.com/2145111124eaa7e5cabe866ee8ef2793.png" class="h-64 mx-auto">

</div>
</div>

[^1]: 画像引用元: https://i.loveruby.net/ja/rhg/cd/callgraph.html

---

# 3.2.2 結合度 (Coupling, カップリング)
- 結合度の分析
    - 求心性結合
        -コードアーティファクト（コンポーネント、クラス、関数）に外部から入力される接続数を計測する
    - 遠心性結合
        - 他のコードアーティファクトに出力する接続数を計測する

---

# 3.2.3 抽象度 (Abstractness)、不安定度 (Instability)
- 抽象度
    - 抽象的なアーティファクト（抽象クラス、インタフェースなど）と具体的なアーティファクト（実装）の比率のこと
- 不安定度
    - 遠心性結合と求心性結合の合計に対する遠心性結合の比率
    - コードベースの不安定度を判断するもの
        - コードベース = 特定のソフトウェアシステム、アプリケーション、ソフトウェアコンポーネントなどを構築するために使用されるソースコードの集まりのこと[^1]
    - 不安定度が高いコードベース
        - 結合度が高く、変更された時に壊れやすい

[^1]: https://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%BC%E3%83%89%E3%83%99%E3%83%BC%E3%82%B9

---

# 3.2.4 主系列からの距離[^1]

<div grid="~ cols-2 gap-4">
<div>

- アーキテクチャ上の構造についてアーキテクトが手にできている**数少ない総合的なメトリクス**
- 不安定度と抽象度から求められる
- あるクラスをグラフにプロットすることで主系列からの距離を測定できる
    - ラインに近いほどバランスの良いクラス
- 右上の領域は「無駄ゾーン」
    - 抽象的すぎて使いにくい
- 左下の領域は「苦痛ゾーン」
    - 具体的すぎて変更に脆くメンテナンス性が低い

</div>
<div>

<img src="https://gyazo.com/b90ba338d155362bd5eeff9baaabd97f.png" class="h-64 mx-auto">

</div>
</div>

[^1]: 画像引用元: https://scrapbox.io/nobuoka-pub/%E4%B8%BB%E7%B3%BB%E5%88%97%E3%81%8B%E3%82%89%E3%81%AE%E8%B7%9D%E9%9B%A2

---

# 3.2.5 コナーセンス
- 求心性と遠心性の結合メトリクスを改良し、オブジェクト指向言語向けに再構築した
- コナーセンスの定義
    - システムの全体的な正しさを維持するため、あるコンポーネントの変更が別のコンポーネントの変更を必要とする場合、2つのコンポーネントはコナーセント（接続）されている
- コナーセンスは静的/動的の2種類がある

---

# 3.2.5.1 静的なコナーセンス
- コードレベルでの結合
- 静的なコナーセンスはいくつかの種類に分けられる
- 名前のコナーセンス
    - 複数のコンポーネントはエンティティの名前に合意する必要がある
    - コードベースが結合される最も一般的で望ましい方法
    - 命名規則のこと？？
- 型のコナーセンス
    - 複数のコンポーネントはエンティティの型に合意する必要がある
    - 変数やパラメータを特定の型に制約する、静的型付け言語に共通する機能を指す

---

# 3.2.5.1 静的なコナーセンス
- 意味のコナーセンス
    - 複数のコンポーネントは特定の値の意味に合意する必要がある
    - 定数を用いずにハードコードされた数値
        - `int TRUE = 1`
        - `int FALSE = 0`
- 位置のコナーセンス
    - 複数のコンポーネントは値の順序に合意する必要がある
    - メソッドの引数の順序
        - `void updateSeat(String name, String seatLocation)`
        - 呼び出し `updateSeat('14D', 'Ford, N')`
        - 型は正しくても意味的には正しくない

---

# 3.2.5.1 静的なコナーセンス
- アルゴリズムのコナーセンス
    - 複数のコンポーネントは特定のアルゴリズムに合意する必要がある
    - 開発者がサーバーとクライアントの両方で実行する必要のあるハッシュアルゴリズムを定義していて、ユーザーを認証するためにサーバー/クライアントで同じ結果を出す必要がある
    - いずれかのアルゴリズムの詳細を変更するとハンドシェイクが機能しなくなる

---

# 3.2.5.2 動的なコナーセンス
- 実行時の呼び出しを分析する
- 動的なコナーセンスはいくつかの種類に分けられる
- 実行順序のコナーセンス
    - 複数のコンポーネントを実行する順序は重要
    - 特定のプロパティを順に設定する必要があるものの、それが行えていないため正しく機能しない

```java
email = new Email();
email.setRecipient('foo@example.com');
email.setSender('me@me.com');
email.send();
email.setSubject('whoops');
```

---

# 3.2.5.2 動的なコナーセンス
- タイミングのコナーセンス
    - 複数のコンポーネントを実行するタイミングは重要
    - 2つのスレッドが同時に実行されることで引き起こされる競合状態
- 値のコナーセンス
    - 複数のコンポーネントが同じエンティティを参照する必要がある場合に発生する
    - 例. 分散システムのトランザクション
    - 例がよくわからない
- アイデンティティのコナーセンス
    - 複数のコンポーネントがあるエンティティの特定のインスタンスに依存している時に発生する

---

# 3.2.5.3 コナーセンスの性質
- コナーセンスはアーキテクトや開発者のための解析ツール
- コナーセンスはいくつかの性質を持つ

---

# 3.2.5.3 コナーセンスの性質[^1]

<div grid="~ cols-2 gap-4">
<div>

- その種のコナーセンスをどれだけ容易にリファクタリング可能か
- コナーセンスの種類には良い/悪いが存在する（図を参照）
- **より良い種類のコナーセンスに向けてリファクタリングすることでコードベースの結合特性を改善できる**

</div>
<div>

<img src="https://gyazo.com/beef34ce6d0560dc4babaf9678b4fc86.png" class="h-64 mx-auto">

</div>
</div>

[^1]: 画像引用元: https://scrapbox.io/nobuoka-pub/%E3%82%B3%E3%83%8A%E3%83%BC%E3%82%BB%E3%83%B3%E3%82%B9

---

# 3.2.5.3 コナーセンスの性質[^1]

<div grid="~ cols-2 gap-4">
<div>

- アーキテクトは動的よりも静的なコナーセンスを好むべき
    - 静的なコナーセンスはコード解析によって改善点を見つけられるため
    - 例. マジックナンバーから名前付き定数へのリファクタリング
        - 値のコナーセンスから意味のコナーセンスへと変化する

</div>
<div>

<img src="https://gyazo.com/beef34ce6d0560dc4babaf9678b4fc86.png" class="h-64 mx-auto">

</div>
</div>

[^1]: 画像引用元: https://scrapbox.io/nobuoka-pub/%E3%82%B3%E3%83%8A%E3%83%BC%E3%82%BB%E3%83%B3%E3%82%B9

---

# 3.2.5.3 コナーセンスの性質
- 位置関係
    - コードベース内におけるモジュール同士の距離を計測する
    - 一般的に距離の近いコード（同じモジュール内）は距離の離れたコード（別々のモジュール）に比べてより高度で多様なコナーセンスの形を持てる
    - 例. 別々のコンポーネントにある2つのクラスが意味のコナーセンスを持っているケースよりも、同じコンポーネントにある2つのクラスが意味のコナーセンスを持っているケースの方がコードベースへのダメージは少ない
- 度合い
    - コナーセンスの影響の大きさに関連する
    - コナーセンスの度合いが低いとコードベースへのダメージは少なくなる

---

# モジュール性を向上させるためのガイドライン 
by Page Jones

1. カプセル化された要素にシステムに分割することで、全体的なコナーセンスの度合いを最小化すること
1. カプセル化の境界をまたぐコナーセンスの度合いはいかなるものであれ最小に抑えること
1. カプセル化の境界内ではコナーセンスの度合いを最大化すること

---

# 度合いと位置関係のルール
by Jim Weirich

- 度合いのルール
    - 強いコナーセンスを弱いコナーセンスに変換しよう
- 位置関係のルール
    - ソフトウェア要素間の距離が遠くなるにつれ、より弱いコナーセンスを使おう

---

# 3.2.6 結合度とコナーセンスのメトリクスを結合する[^1]

<div grid="~ cols-2 gap-4">
<div>

- 結合度とコナーセンス
    - 異なる時代に異なる対象を計測するものとして登場した
    - この2つの観点は重なり合っている
        - 静的なコナーセンス = 求心性結合と遠心性結合の度合い
    - 結合度の概念を左、コナーセンスの特性を右に示している

</div>
<div>

<img src="https://gyazo.com/5ea876e521d35b0aa1d37e1ecdabe20a.png" class="h-48 mx-auto">

</div>
</div>

[^1]: 画像引用元: https://scrapbox.io/nobuoka-pub/%E7%B5%90%E5%90%88%E5%BA%A6%E3%81%A8%E3%82%B3%E3%83%8A%E3%83%BC%E3%82%BB%E3%83%B3%E3%82%B9

---

# 3.2.6.1 1990年代のコナーセンスが持っていた問題
- これらのメトリクスをシステムの分析や設計に適用する場合、アーキテクトはコナーセンスに関するいくつかの問題を抱える
    1. これらのメトリクスはコードの低レベルの詳細を見ており、コードの品質と健康状態に焦点を当てている
        - アーキテクトは結合の度合いよりもモジュールが「どう」結合されているかに関心を持つ
    2. マイクロサービスのような分散アーキテクチャで同期通信をするか非同期通信をするか、といった点にあまり対処していない
        - 7章で現代のコナーセンスについての新しい考え方を紹介する

---

# 3.3 モジュールからコンポーネントへ
- 本書では関連するコードをまとめたものの総称としてモジュールという用語を使用している
- ほとんどのプラットフォームではモジュール以外にコンポーネントも何らかの形でサポートしている
- 論理的な分離と物理的な分離の考え方と、それらに対応する分析方法がある
    - モジュールとコンポーネントの違いとは？
        - モジュール = 論理的な分離
        - コンポーネント = 物理的な分離
- 問題領域からコンポーネントを導き出すことについては8章で説明する。
